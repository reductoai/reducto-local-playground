/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/split": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Split */
        post: operations["split_split_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/split_async": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Split Async */
        post: operations["split_async_split_async_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/parse": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Parse */
        post: operations["parse_parse_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/extract": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Extract */
        post: operations["extract_extract_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/extract_async": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Extract Async */
        post: operations["extract_async_extract_async_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/parse_async": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Async Parse */
        post: operations["async_parse_parse_async_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/job/{job_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve Parse */
        get: operations["retrieve_parse_job__job_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/cancel/{job_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Cancel Job */
        post: operations["cancel_job_cancel__job_id__post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/upload": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Upload */
        post: operations["upload_upload_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/configure_webhook": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Webhook Portal */
        post: operations["webhook_portal_configure_webhook_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/version": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Version */
        get: operations["get_version_version_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** AdvancedProcessingOptions */
        AdvancedProcessingOptions: {
            /**
             * Ocr System
             * @description The OCR system to use. Highres is recommended for documents with English characters.
             * @default highres
             * @enum {string}
             */
            ocr_system?: "highres" | "multilingual" | "combined";
            /**
             * Table Output Format
             * @description The mode to use for table output. Dynamic returns md for simpler tables and html for more complex tables.
             * @default html
             * @enum {string}
             */
            table_output_format?: "html" | "json" | "md" | "jsonbbox" | "dynamic" | "ai_json" | "csv";
            /**
             * Merge Tables
             * @description A flag to indicate if consecutive tables with the same number of columns should be merged across breaks and spaces.
             * @default false
             */
            merge_tables?: boolean;
            /**
             * Continue Hierarchy
             * @description A flag to indicate if the hierarchy of the document should be continued from chunk to chunk.
             * @default true
             */
            continue_hierarchy?: boolean;
            /**
             * Keep Line Breaks
             * @description If line breaks should be preserved in the text.
             * @default false
             */
            keep_line_breaks?: boolean;
            /**
             * Page Range
             * @description The page range to process (1-indexed). By default, the entire document is processed.
             * @default {}
             */
            page_range?: components["schemas"]["PageRange"] | components["schemas"]["PageRange"][] | number[];
            /**
             * Force File Extension
             * @description Force the URL to be downloaded as a specific file extension (e.g. .png).
             */
            force_file_extension?: string;
            /**
             * @description The configuration options for large table chunking (currently only supported on spreadsheet and CSV files).
             * @default {
             *       "enabled": true,
             *       "size": 50
             *     }
             */
            large_table_chunking?: components["schemas"]["LargeTableChunkingConfig"];
            /**
             * Spreadsheet Table Clustering
             * @description In a spreadsheet with different tables inside, we enable splitting up the tables by default. Disabling will register as one large table.
             * @default default
             * @enum {string}
             */
            spreadsheet_table_clustering?: "default" | "disabled";
            /**
             * Add Page Markers
             * @description If True, add page markers to the output (e.g. [[PAGE 1 BEGINS HERE]] and [[PAGE 1 ENDS HERE]] added as blocks to the content). Defaults to False.
             * @default false
             */
            add_page_markers?: boolean;
            /**
             * Remove Text Formatting
             * @description If True, remove text formatting from the output (e.g. hyphens for list items). Defaults to False.
             * @default false
             */
            remove_text_formatting?: boolean;
            /**
             * Return Ocr Data
             * @description If True, return OCR data in the result. Defaults to False.
             * @default false
             */
            return_ocr_data?: boolean;
            /**
             * Document Password
             * @description Password to decrypt password-protected documents.
             */
            document_password?: string;
            /**
             * Filter Line Numbers
             * @description If True, filter out line numbers from the output. Defaults to False.
             * @default false
             */
            filter_line_numbers?: boolean;
            /**
             * Read Comments
             * @description If True, pull in PDF comments from the document. Defaults to False.
             * @default false
             */
            read_comments?: boolean;
            /**
             * Persist Results
             * @description If True, persist the results indefinitely. Defaults to False.
             * @default false
             */
            persist_results?: boolean;
        };
        /** ArrayExtractConfig */
        ArrayExtractConfig: {
            /**
             * Enabled
             * @description Array extraction allows you to extract long lists of information from lengthy documents. It makes parallel calls on overlapping sections of the document.
             * @default false
             */
            enabled?: boolean;
            /**
             * Mode
             * @description The array extraction version to use.
             * @default legacy
             * @enum {string}
             */
            mode?: "auto" | "legacy" | "streaming" | "no_overlap";
            /**
             * Pages Per Segment
             * @description Length of each segment, in pages, for parallel calls with array extraction.
             * @default 10
             */
            pages_per_segment?: number;
            /**
             * Streaming Extract Item Density
             * @description Number of items to extract in each stream call. Lower numbers will increase quality but be much slower. 50 works well for most documents with tables.
             * @default 50
             */
            streaming_extract_item_density?: number;
        };
        /** AsyncConfig */
        AsyncConfig: {
            /**
             * Enabled
             * @default false
             */
            enabled?: boolean;
            /** Webhook */
            webhook?: components["schemas"]["WebhookConfig"];
            /**
             * Priority
             * @default false
             */
            priority?: boolean;
        };
        /** AsyncExtractConfigNew */
        AsyncExtractConfigNew: {
            /** @default {
             *       "ocr_mode": "standard",
             *       "extraction_mode": "ocr",
             *       "chunking": {
             *         "chunk_mode": "variable"
             *       },
             *       "table_summary": {
             *         "enabled": false
             *       },
             *       "figure_summary": {
             *         "enabled": false,
             *         "override": false
             *       },
             *       "filter_blocks": [],
             *       "force_url_result": false
             *     } */
            options?: components["schemas"]["BaseProcessingOptions"];
            /** @default {
             *       "ocr_system": "highres",
             *       "table_output_format": "html",
             *       "merge_tables": false,
             *       "continue_hierarchy": true,
             *       "keep_line_breaks": false,
             *       "page_range": {},
             *       "large_table_chunking": {
             *         "enabled": true,
             *         "size": 50
             *       },
             *       "spreadsheet_table_clustering": "default",
             *       "add_page_markers": false,
             *       "remove_text_formatting": false,
             *       "return_ocr_data": false,
             *       "filter_line_numbers": false,
             *       "read_comments": false,
             *       "persist_results": false
             *     } */
            advanced_options?: components["schemas"]["AdvancedProcessingOptions"];
            /** @default {
             *       "enrich": {
             *         "enabled": false,
             *         "mode": "standard"
             *       },
             *       "native_office_conversion": false,
             *       "enable_checkboxes": false,
             *       "enable_equations": false,
             *       "rotate_pages": true,
             *       "enable_scripts": false,
             *       "return_figure_images": false,
             *       "return_table_images": false,
             *       "layout_model": "default",
             *       "danger_filter_wide_boxes": false
             *     } */
            experimental_options?: components["schemas"]["ExperimentalProcessingOptions"];
            /**
             * Document Url
             * @description The URL of the document to be processed. You can provide one of the following:
             *     1. A publicly available URL
             *     2. A presigned S3 URL
             *     3. A reducto:// prefixed URL obtained from the /upload endpoint after directly uploading a document
             *     4. A job_id (jobid://) or a list of job_ids (jobid://) obtained from a previous /parse endpoint
             *
             */
            document_url: string | string[] | components["schemas"]["UploadResponse"];
            /**
             * Schema
             * @description The JSON schema to use for extraction.
             */
            schema: unknown;
            /**
             * System Prompt
             * @description A system prompt to use for the extraction. This is a general prompt that is applied to the entire document before any other prompts.
             * @default Be precise and thorough.
             */
            system_prompt?: string;
            /**
             * Generate Citations
             * @description If citations should be generated for the extracted content.
             * @default false
             */
            generate_citations?: boolean;
            /**
             * @description The configuration options for array extract
             * @default {
             *       "enabled": false,
             *       "mode": "legacy",
             *       "pages_per_segment": 10,
             *       "streaming_extract_item_density": 50
             *     }
             */
            array_extract?: components["schemas"]["ArrayExtractConfig"];
            /**
             * Use Chunking
             * @description If chunking should be used for the extraction. Defaults to False.
             * @default false
             */
            use_chunking?: boolean;
            /**
             * Priority
             * @description If True, attempts to process the job with priority if the user has priority processing budget available; by default, sync jobs are prioritized above async jobs.
             * @default false
             */
            priority?: boolean;
            /** @default {
             *       "mode": "disabled",
             *       "channels": []
             *     } */
            webhook?: components["schemas"]["WebhookConfigNew"];
        };
        /** AsyncExtractResponse */
        AsyncExtractResponse: {
            /** Job Id */
            job_id: string;
        };
        /** AsyncJobResponse */
        AsyncJobResponse: {
            /**
             * Status
             * @enum {string}
             */
            status: "Pending" | "Completed" | "Failed" | "Idle";
            /** Result */
            result?: components["schemas"]["ParseResponse"] | components["schemas"]["ExtractResponse"] | components["schemas"]["SplitResponse"] | components["schemas"]["EditResponse"] | null;
            /** Progress */
            progress?: number | null;
            /** Reason */
            reason?: string | null;
        };
        /** AsyncParseConfigNew */
        AsyncParseConfigNew: {
            /** @default {
             *       "ocr_mode": "standard",
             *       "extraction_mode": "ocr",
             *       "chunking": {
             *         "chunk_mode": "variable"
             *       },
             *       "table_summary": {
             *         "enabled": false
             *       },
             *       "figure_summary": {
             *         "enabled": false,
             *         "override": false
             *       },
             *       "filter_blocks": [],
             *       "force_url_result": false
             *     } */
            options?: components["schemas"]["BaseProcessingOptions"];
            /** @default {
             *       "ocr_system": "highres",
             *       "table_output_format": "html",
             *       "merge_tables": false,
             *       "continue_hierarchy": true,
             *       "keep_line_breaks": false,
             *       "page_range": {},
             *       "large_table_chunking": {
             *         "enabled": true,
             *         "size": 50
             *       },
             *       "spreadsheet_table_clustering": "default",
             *       "add_page_markers": false,
             *       "remove_text_formatting": false,
             *       "return_ocr_data": false,
             *       "filter_line_numbers": false,
             *       "read_comments": false,
             *       "persist_results": false
             *     } */
            advanced_options?: components["schemas"]["AdvancedProcessingOptions"];
            /** @default {
             *       "enrich": {
             *         "enabled": false,
             *         "mode": "standard"
             *       },
             *       "native_office_conversion": false,
             *       "enable_checkboxes": false,
             *       "enable_equations": false,
             *       "rotate_pages": true,
             *       "enable_scripts": false,
             *       "return_figure_images": false,
             *       "return_table_images": false,
             *       "layout_model": "default",
             *       "danger_filter_wide_boxes": false
             *     } */
            experimental_options?: components["schemas"]["ExperimentalProcessingOptions"];
            /**
             * Document Url
             * @description The URL of the document to be processed. You can provide one of the following:
             *     1. A publicly available URL
             *     2. A presigned S3 URL
             *     3. A reducto:// prefixed URL obtained from the /upload endpoint after directly uploading a document
             */
            document_url: string | components["schemas"]["UploadResponse"];
            /**
             * Priority
             * @description If True, attempts to process the job with priority if the user has priority processing budget available; by default, sync jobs are prioritized above async jobs.
             * @default false
             */
            priority?: boolean;
            /** @default {
             *       "mode": "disabled",
             *       "channels": []
             *     } */
            webhook?: components["schemas"]["WebhookConfigNew"];
        };
        /** AsyncParseResponse */
        AsyncParseResponse: {
            /** Job Id */
            job_id: string;
        };
        /** AsyncSplitConfig */
        AsyncSplitConfig: {
            /** @default {
             *       "ocr_mode": "standard",
             *       "extraction_mode": "ocr",
             *       "chunking": {
             *         "chunk_mode": "variable"
             *       },
             *       "table_summary": {
             *         "enabled": false
             *       },
             *       "figure_summary": {
             *         "enabled": false,
             *         "override": false
             *       },
             *       "filter_blocks": [],
             *       "force_url_result": false
             *     } */
            options?: components["schemas"]["BaseProcessingOptions"];
            /** @default {
             *       "ocr_system": "highres",
             *       "table_output_format": "html",
             *       "merge_tables": false,
             *       "continue_hierarchy": true,
             *       "keep_line_breaks": false,
             *       "page_range": {},
             *       "large_table_chunking": {
             *         "enabled": true,
             *         "size": 50
             *       },
             *       "spreadsheet_table_clustering": "default",
             *       "add_page_markers": false,
             *       "remove_text_formatting": false,
             *       "return_ocr_data": false,
             *       "filter_line_numbers": false,
             *       "read_comments": false,
             *       "persist_results": false
             *     } */
            advanced_options?: components["schemas"]["AdvancedProcessingOptions"];
            /** @default {
             *       "enrich": {
             *         "enabled": false,
             *         "mode": "standard"
             *       },
             *       "native_office_conversion": false,
             *       "enable_checkboxes": false,
             *       "enable_equations": false,
             *       "rotate_pages": true,
             *       "enable_scripts": false,
             *       "return_figure_images": false,
             *       "return_table_images": false,
             *       "layout_model": "default",
             *       "danger_filter_wide_boxes": false
             *     } */
            experimental_options?: components["schemas"]["ExperimentalProcessingOptions"];
            /**
             * Document Url
             * @description The URL of the document to be processed. You can provide one of the following:
             *     1. A publicly available URL
             *     2. A presigned S3 URL
             *     3. A reducto:// prefixed URL obtained from the /upload endpoint after directly uploading a document
             *     4. A job_id (jobid://) or a list of job_ids (jobid://) obtained from a previous /parse endpoint
             *
             */
            document_url: string | string[] | components["schemas"]["UploadResponse"];
            /**
             * Priority
             * @description If True, attempts to process the job with priority if the user has priority processing budget available; by default, sync jobs are prioritized above async jobs.
             * @default false
             */
            priority?: boolean;
            /**
             * Split Description
             * @description The configuration options for processing the document.
             */
            split_description: components["schemas"]["SplitCategory"][];
            /**
             * Split Rules
             * @description The prompt that describes rules for splitting the document.
             * @default Split the document into the applicable sections. Sections may only overlap at their first and last page if at all.
             */
            split_rules?: string;
            /** @default {
             *       "mode": "disabled",
             *       "channels": []
             *     } */
            webhook?: components["schemas"]["WebhookConfigNew"];
        };
        /** AsyncSplitResponse */
        AsyncSplitResponse: {
            /** Job Id */
            job_id: string;
        };
        /** BaseProcessingOptions */
        BaseProcessingOptions: {
            /**
             * Ocr Mode
             * @description The mode to use for OCR. Agentic mode adds an extra pass, correcting any table/text mistakes at a small cost.
             * @default standard
             * @enum {string}
             */
            ocr_mode?: "standard" | "agentic";
            /**
             * Extraction Mode
             * @description The mode to use for extraction. Metadata/hybrid are only recommended with high quality metadata embeddings.
             * @default ocr
             * @enum {string}
             */
            extraction_mode?: "ocr" | "metadata" | "hybrid";
            /**
             * @description The configuration options for chunking. Chunking is commonly used for RAG usecases.
             * @default {
             *       "chunk_mode": "variable"
             *     }
             */
            chunking?: components["schemas"]["ChunkingConfig"];
            /**
             * @description The configuration options for table summarization.
             * @default {
             *       "enabled": false
             *     }
             */
            table_summary?: components["schemas"]["TableSummaryConfig"];
            /**
             * @description The configuration options for figure summarization.
             * @default {
             *       "enabled": false,
             *       "override": false
             *     }
             */
            figure_summary?: components["schemas"]["FigureSummaryConfig"];
            /**
             * Filter Blocks
             * @description A list of block types to filter from chunk content. Pass blocks to filter them from content. By default, no blocks are filtered.
             * @default []
             */
            filter_blocks?: ("Header" | "Footer" | "Title" | "Section Header" | "Page Number" | "List Item" | "Figure" | "Table" | "Key Value" | "Text" | "Comment")[];
            /**
             * Force Url Result
             * @description Force the result to be returned in URL form (by default only used for very large responses).
             * @default false
             */
            force_url_result?: boolean;
        };
        /** Body_upload_upload_post */
        Body_upload_upload_post: {
            /** File */
            file?: string | null;
        };
        /** BoundingBox */
        BoundingBox: {
            /** Left */
            left: number;
            /** Top */
            top: number;
            /** Width */
            width: number;
            /** Height */
            height: number;
            /**
             * Page
             * @description The page number of the bounding box (1-indexed).
             */
            page: number;
            /**
             * Original Page
             * @description The page number in the original document of the bounding box (1-indexed).
             */
            original_page?: number;
        };
        /** ChunkingConfig */
        ChunkingConfig: {
            /**
             * Chunk Mode
             * @description Choose how to partition chunks. Variable mode chunks by character length and visual context. Section mode chunks by section headers. Page mode chunks according to pages. Page sections mode chunks first by page, then by sections within each page. Disabled returns one single chunk.
             * @default variable
             * @enum {string}
             */
            chunk_mode?: "variable" | "section" | "page" | "block" | "disabled" | "page_sections";
            /**
             * Chunk Size
             * @description The approximate size of chunks (in characters) that the document will be split into. Defaults to None, in which case the chunk size is variable between 250 - 1500 characters.
             */
            chunk_size?: number;
        };
        /** EditResponse */
        EditResponse: {
            /** Document Url */
            document_url: string;
        };
        /** EnrichConfig */
        EnrichConfig: {
            /**
             * Enabled
             * @description If enabled, a large language/vision model will be used to postprocess the extracted content. Note: enabling enrich requires tables be outputted in markdown format. Defaults to False.
             * @default false
             */
            enabled?: boolean;
            /**
             * Mode
             * @description The mode to use for enrichment. Defaults to standard
             * @default standard
             * @enum {string}
             */
            mode?: "standard" | "page" | "table";
            /**
             * Prompt
             * @description Add information to the prompt for enrichment.
             */
            prompt?: string;
        };
        /** ExperimentalProcessingOptions */
        ExperimentalProcessingOptions: {
            /**
             * @description The configuration options for enrichment.
             * @default {
             *       "enabled": false,
             *       "mode": "standard"
             *     }
             */
            enrich?: components["schemas"]["EnrichConfig"];
            /**
             * Native Office Conversion
             * @description Instead of using LibreOffice, when enabled, this flag uses a Windows VM to convert files. This is slower but more accurate.
             * @default false
             */
            native_office_conversion?: boolean;
            /**
             * Enable Checkboxes
             * @description Use an experimental checkbox detection model to add checkboxes to the output, defaults to False
             * @default false
             */
            enable_checkboxes?: boolean;
            /**
             * Enable Equations
             * @description Use an experimental equation detection model to add equations to the output, defaults to False
             * @default false
             */
            enable_equations?: boolean;
            /**
             * Rotate Pages
             * @description Use an orientation model to detect and rotate pages as needed, defaults to True
             * @default true
             */
            rotate_pages?: boolean;
            /**
             * Enable Scripts
             * @description Add <sub> tag around subscripts and <sup> tag around superscripts, defaults to False
             * @default false
             */
            enable_scripts?: boolean;
            /**
             * Return Figure Images
             * @description If figure images should be returned in the result. Defaults to False.
             * @default false
             */
            return_figure_images?: boolean;
            /**
             * Return Table Images
             * @description If table images should be returned in the result. Defaults to False.
             * @default false
             */
            return_table_images?: boolean;
            /**
             * Layout Model
             * @description The layout model to use for the document. This will be deprecated in the future.
             * @default default
             * @enum {string}
             */
            layout_model?: "default" | "beta";
            /**
             * Danger Filter Wide Boxes
             * @description You probably shouldn't use this. If True, filter out boxes with width greater than 50% of the document width. Defaults to False. You probably don't want to use this.
             * @default false
             */
            danger_filter_wide_boxes?: boolean;
        } & {
            [key: string]: unknown;
        };
        /** ExtractConfig */
        ExtractConfig: {
            /** Document Url */
            document_url: string | string[];
            /**
             * @description The configuration options for extraction.
             * @default {
             *       "pdf_ocr": "ocr",
             *       "ocr_system": "textract",
             *       "ocr_mode": "standard",
             *       "table_output_format": "html",
             *       "infer_table_color": false,
             *       "chunk_mode": "variable",
             *       "disable_chunking": true,
             *       "continue_hierarchy": true,
             *       "mode": "document",
             *       "table_summary": true,
             *       "figure_summary": false,
             *       "figure_summary_override": false,
             *       "summarize_all_figures": false,
             *       "chart_extract": false,
             *       "enrich": false,
             *       "enrich_mode": "standard",
             *       "beta_layout_enrichment": false,
             *       "ignore_blocks": [],
             *       "merge_tables": false,
             *       "dpi": 150,
             *       "force_url_result": false,
             *       "use_fast_inference": false,
             *       "use_gpu_ocr": false,
             *       "max_batch_size": 10,
             *       "num_ocr_crops": 2,
             *       "timeout": 900,
             *       "extra_metadata": {},
             *       "embed_text_metadata_pdf": false,
             *       "enhanced_docx_conversion": false,
             *       "json_bbox": false,
             *       "experimental_large_spreadsheet_table_chunking": false,
             *       "use_checkboxes": false,
             *       "use_equations": false,
             *       "page_range": [
             *         {}
             *       ],
             *       "keep_line_breaks": false,
             *       "overlap_threshold": 0.5,
             *       "large_table_chunking": true,
             *       "large_table_chunking_size": 50,
             *       "rotate_pages": false,
             *       "enable_underlines": false,
             *       "enable_scripts": false,
             *       "enable_comments": false,
             *       "return_figure_images": false,
             *       "return_table_images": false,
             *       "spreadsheet_table_clustering": "default",
             *       "danger_filter_wide_boxes": false,
             *       "add_page_markers": false,
             *       "remove_text_formatting": false,
             *       "return_ocr_data": false,
             *       "filter_line_numbers": false,
             *       "layout_model": "default",
             *       "persist_results": false
             *     }
             */
            parse_config?: components["schemas"]["ProcessingOptions"];
            /**
             * @description The configuration options for extraction.
             * @default {
             *       "generate_citations": false,
             *       "array_extract": false,
             *       "array_extract_pages": 10,
             *       "extract_algorithm": "legacy",
             *       "streaming_extract_item_density": 50
             *     }
             */
            options?: components["schemas"]["ExtractConfigOptions"];
            /**
             * Schema
             * @description The JSON schema to use for extraction.
             */
            schema: unknown;
            /**
             * System Prompt
             * @description A system prompt to use for the extraction. This is a general prompt that is applied to the entire document before any other prompts.
             * @default Be concise.
             */
            system_prompt?: string;
            /**
             * Alpha Deep Extract
             * @default false
             */
            alpha_deep_extract?: boolean;
            /**
             * Alpha Table Citations
             * @default false
             */
            alpha_table_citations?: boolean;
            /**
             * Alpha Big Extraction Model
             * @default false
             */
            alpha_big_extraction_model?: boolean;
            /**
             * @description The configuration options for asynchronous processing (default synchronous).
             * @default {
             *       "enabled": false,
             *       "priority": false
             *     }
             */
            async?: components["schemas"]["AsyncConfig"];
            /**
             * Priority
             * @description If True, attempts to process the job with priority if the user has priority processing budget available; by default, sync jobs are prioritized above async jobs.
             * @default true
             */
            priority?: boolean;
            /**
             * User Config
             * @description User-specific configuration options.
             */
            user_config?: {
                [key: string]: unknown;
            };
        };
        /** ExtractConfigNew */
        ExtractConfigNew: {
            /** @default {
             *       "ocr_mode": "standard",
             *       "extraction_mode": "ocr",
             *       "chunking": {
             *         "chunk_mode": "variable"
             *       },
             *       "table_summary": {
             *         "enabled": false
             *       },
             *       "figure_summary": {
             *         "enabled": false,
             *         "override": false
             *       },
             *       "filter_blocks": [],
             *       "force_url_result": false
             *     } */
            options?: components["schemas"]["BaseProcessingOptions"];
            /** @default {
             *       "ocr_system": "highres",
             *       "table_output_format": "html",
             *       "merge_tables": false,
             *       "continue_hierarchy": true,
             *       "keep_line_breaks": false,
             *       "page_range": {},
             *       "large_table_chunking": {
             *         "enabled": true,
             *         "size": 50
             *       },
             *       "spreadsheet_table_clustering": "default",
             *       "add_page_markers": false,
             *       "remove_text_formatting": false,
             *       "return_ocr_data": false,
             *       "filter_line_numbers": false,
             *       "read_comments": false,
             *       "persist_results": false
             *     } */
            advanced_options?: components["schemas"]["AdvancedProcessingOptions"];
            /** @default {
             *       "enrich": {
             *         "enabled": false,
             *         "mode": "standard"
             *       },
             *       "native_office_conversion": false,
             *       "enable_checkboxes": false,
             *       "enable_equations": false,
             *       "rotate_pages": true,
             *       "enable_scripts": false,
             *       "return_figure_images": false,
             *       "return_table_images": false,
             *       "layout_model": "default",
             *       "danger_filter_wide_boxes": false
             *     } */
            experimental_options?: components["schemas"]["ExperimentalProcessingOptions"];
            /**
             * Document Url
             * @description The URL of the document to be processed. You can provide one of the following:
             *     1. A publicly available URL
             *     2. A presigned S3 URL
             *     3. A reducto:// prefixed URL obtained from the /upload endpoint after directly uploading a document
             *     4. A job_id (jobid://) or a list of job_ids (jobid://) obtained from a previous /parse endpoint
             *
             */
            document_url: string | string[] | components["schemas"]["UploadResponse"];
            /**
             * Schema
             * @description The JSON schema to use for extraction.
             */
            schema: unknown;
            /**
             * System Prompt
             * @description A system prompt to use for the extraction. This is a general prompt that is applied to the entire document before any other prompts.
             * @default Be precise and thorough.
             */
            system_prompt?: string;
            /**
             * Generate Citations
             * @description If citations should be generated for the extracted content.
             * @default false
             */
            generate_citations?: boolean;
            /**
             * @description The configuration options for array extract
             * @default {
             *       "enabled": false,
             *       "mode": "legacy",
             *       "pages_per_segment": 10,
             *       "streaming_extract_item_density": 50
             *     }
             */
            array_extract?: components["schemas"]["ArrayExtractConfig"];
            /**
             * Use Chunking
             * @description If chunking should be used for the extraction. Defaults to False.
             * @default false
             */
            use_chunking?: boolean;
            /**
             * Priority
             * @description If True, attempts to process the job with priority if the user has priority processing budget available; by default, sync jobs are prioritized above async jobs.
             * @default true
             */
            priority?: boolean;
        };
        /** ExtractConfigOptions */
        ExtractConfigOptions: {
            /**
             * Generate Citations
             * @description If citations should be generated for the extracted content.
             * @default false
             */
            generate_citations?: boolean;
            /**
             * Array Extract
             * @description Array extraction allows you to extract long lists of information from lengthy documents. It makes parallel calls on overlapping sections of the document.
             * @default false
             */
            array_extract?: boolean;
            /**
             * Array Extract Pages
             * @description Length of each segment, in pages, for parallel calls with array extraction.
             * @default 10
             */
            array_extract_pages?: number;
            /**
             * Extract Algorithm
             * @description The array extraction version to use.
             * @default legacy
             * @enum {string}
             */
            extract_algorithm?: "legacy" | "streaming" | "no_overlap";
            /**
             * Streaming Extract Item Density
             * @description Number of items to extract in each stream call.
             * @default 50
             */
            streaming_extract_item_density?: number;
        };
        /** ExtractResponse */
        ExtractResponse: {
            usage: components["schemas"]["ExtractUsage"];
            /**
             * Result
             * @description The extracted response in your provided schema. This is a list of dictionaries. If disbale_chunking is True (default), then it will be a list of length one.
             */
            result: unknown[];
            /**
             * Citations
             * @description The citations corresponding to the extracted response.
             */
            citations: unknown[] | null;
        };
        /** ExtractUsage */
        ExtractUsage: {
            /** Num Pages */
            num_pages: number;
            /** Num Fields */
            num_fields: number;
        };
        /** FigureSummaryConfig */
        FigureSummaryConfig: {
            /**
             * Enabled
             * @description If figure summarization should be performed.
             * @default false
             */
            enabled?: boolean;
            /**
             * Prompt
             * @description Add information to the prompt for figure summarization. Note any visual cues that should be incorporated. Example: 'When provided a diagram, extract all of the figure content verbatim.'
             */
            prompt?: string;
            /**
             * Override
             * @description If the figure summary prompt should override our default prompt.
             * @default false
             */
            override?: boolean;
        };
        /** FullResult */
        FullResult: {
            /**
             * Type
             * @description type = 'full'
             * @constant
             */
            type: "full";
            /** Chunks */
            chunks: components["schemas"]["ParseChunk"][];
            ocr?: components["schemas"]["OCRResult"] | null;
            /** Custom */
            custom?: unknown | null;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /** LargeTableChunkingConfig */
        LargeTableChunkingConfig: {
            /**
             * Enabled
             * @description If large tables should be chunked into smaller tables, currently only supported on spreadsheet and CSV files.
             * @default true
             */
            enabled?: boolean;
            /**
             * Size
             * @description The max row/column size for a table to be chunked. Defaults to 50. Header rows/columns are persisted based on heuristics.
             * @default 50
             */
            size?: number;
        };
        /** OCRLine */
        OCRLine: {
            /** Text */
            text: string;
            bbox: components["schemas"]["BoundingBox"];
        };
        /** OCRResult */
        OCRResult: {
            /** Words */
            words: components["schemas"]["OCRWord"][];
            /** Lines */
            lines: components["schemas"]["OCRLine"][];
        };
        /** OCRWord */
        OCRWord: {
            /** Text */
            text: string;
            bbox: components["schemas"]["BoundingBox"];
        };
        /** PageRange */
        PageRange: {
            /**
             * Start
             * @description The page number to start processing from (1-indexed).
             */
            start?: number | null;
            /**
             * End
             * @description The page number to stop processing at (1-indexed).
             */
            end?: number | null;
        };
        /** ParseBlock */
        ParseBlock: {
            /**
             * Type
             * @description The type of block extracted from the document.
             * @enum {string}
             */
            type: "Header" | "Footer" | "Title" | "Section Header" | "Page Number" | "List Item" | "Figure" | "Table" | "Key Value" | "Text" | "Comment";
            /** @description The bounding box of the block extracted from the document. */
            bbox: components["schemas"]["BoundingBox"];
            /**
             * Content
             * @description The content of the block extracted from the document.
             */
            content: string;
            /**
             * Image Url
             * @description (Experimental) The URL of the image associated with the block.
             */
            image_url?: string | null;
            /**
             * Confidence
             * @description The confidence for the block. It is either low or high and takes into account factors like OCR and table structure
             */
            confidence?: string | null;
        };
        /** ParseChunk */
        ParseChunk: {
            /**
             * Content
             * @description The content of the chunk extracted from the document.
             */
            content: string;
            /**
             * Embed
             * @description Chunk content optimized for embedding and retrieval.
             */
            embed: string;
            /**
             * Enriched
             * @description The enriched content of the chunk extracted from the document.
             */
            enriched: string | null;
            /**
             * Enrichment Success
             * @description Whether the enrichment was successful.
             * @default false
             */
            enrichment_success?: boolean;
            /** Blocks */
            blocks: components["schemas"]["ParseBlock"][];
        };
        /**
         * ParseConfig
         * @description Configuration for parsing a document
         */
        ParseConfig: {
            /**
             * Document Url
             * @description The URL of the document to process. Either a public URL or a presigned URL with a valid expiration time.
             */
            document_url: string | string[];
            /**
             * @description The configuration options for processing the document.
             * @default {
             *       "pdf_ocr": "ocr",
             *       "ocr_system": "textract",
             *       "ocr_mode": "standard",
             *       "table_output_format": "html",
             *       "infer_table_color": false,
             *       "chunk_mode": "variable",
             *       "disable_chunking": false,
             *       "continue_hierarchy": true,
             *       "mode": "document",
             *       "table_summary": true,
             *       "figure_summary": false,
             *       "figure_summary_override": false,
             *       "summarize_all_figures": false,
             *       "chart_extract": false,
             *       "enrich": false,
             *       "enrich_mode": "standard",
             *       "beta_layout_enrichment": false,
             *       "ignore_blocks": [],
             *       "merge_tables": false,
             *       "dpi": 150,
             *       "force_url_result": false,
             *       "use_fast_inference": false,
             *       "use_gpu_ocr": false,
             *       "max_batch_size": 10,
             *       "num_ocr_crops": 2,
             *       "timeout": 900,
             *       "extra_metadata": {},
             *       "embed_text_metadata_pdf": false,
             *       "enhanced_docx_conversion": false,
             *       "json_bbox": false,
             *       "experimental_large_spreadsheet_table_chunking": false,
             *       "use_checkboxes": false,
             *       "use_equations": false,
             *       "page_range": [
             *         {}
             *       ],
             *       "keep_line_breaks": false,
             *       "overlap_threshold": 0.5,
             *       "large_table_chunking": true,
             *       "large_table_chunking_size": 50,
             *       "rotate_pages": false,
             *       "enable_underlines": false,
             *       "enable_scripts": false,
             *       "enable_comments": false,
             *       "return_figure_images": false,
             *       "return_table_images": false,
             *       "spreadsheet_table_clustering": "default",
             *       "danger_filter_wide_boxes": false,
             *       "add_page_markers": false,
             *       "remove_text_formatting": false,
             *       "return_ocr_data": false,
             *       "filter_line_numbers": false,
             *       "layout_model": "default",
             *       "persist_results": false
             *     }
             */
            config?: components["schemas"]["ProcessingOptions"];
            /**
             * @description The configuration options for asynchronous processing (default synchronous).
             * @default {
             *       "enabled": false,
             *       "priority": false
             *     }
             */
            async?: components["schemas"]["AsyncConfig"];
            /**
             * Priority
             * @description If True, attempts to process the job with priority if the user has priority processing budget available; by default, sync jobs are prioritized above async jobs.
             * @default true
             */
            priority?: boolean;
            /**
             * User Config
             * @description User-specific configuration options.
             */
            user_config?: {
                [key: string]: unknown;
            };
        };
        /** ParseConfigNew */
        ParseConfigNew: {
            /** @default {
             *       "ocr_mode": "standard",
             *       "extraction_mode": "ocr",
             *       "chunking": {
             *         "chunk_mode": "variable"
             *       },
             *       "table_summary": {
             *         "enabled": false
             *       },
             *       "figure_summary": {
             *         "enabled": false,
             *         "override": false
             *       },
             *       "filter_blocks": [],
             *       "force_url_result": false
             *     } */
            options?: components["schemas"]["BaseProcessingOptions"];
            /** @default {
             *       "ocr_system": "highres",
             *       "table_output_format": "html",
             *       "merge_tables": false,
             *       "continue_hierarchy": true,
             *       "keep_line_breaks": false,
             *       "page_range": {},
             *       "large_table_chunking": {
             *         "enabled": true,
             *         "size": 50
             *       },
             *       "spreadsheet_table_clustering": "default",
             *       "add_page_markers": false,
             *       "remove_text_formatting": false,
             *       "return_ocr_data": false,
             *       "filter_line_numbers": false,
             *       "read_comments": false,
             *       "persist_results": false
             *     } */
            advanced_options?: components["schemas"]["AdvancedProcessingOptions"];
            /** @default {
             *       "enrich": {
             *         "enabled": false,
             *         "mode": "standard"
             *       },
             *       "native_office_conversion": false,
             *       "enable_checkboxes": false,
             *       "enable_equations": false,
             *       "rotate_pages": true,
             *       "enable_scripts": false,
             *       "return_figure_images": false,
             *       "return_table_images": false,
             *       "layout_model": "default",
             *       "danger_filter_wide_boxes": false
             *     } */
            experimental_options?: components["schemas"]["ExperimentalProcessingOptions"];
            /**
             * Document Url
             * @description The URL of the document to be processed. You can provide one of the following:
             *     1. A publicly available URL
             *     2. A presigned S3 URL
             *     3. A reducto:// prefixed URL obtained from the /upload endpoint after directly uploading a document
             */
            document_url: string | components["schemas"]["UploadResponse"];
            /**
             * Priority
             * @description If True, attempts to process the job with priority if the user has priority processing budget available; by default, sync jobs are prioritized above async jobs.
             * @default true
             */
            priority?: boolean;
        };
        /** ParseResponse */
        ParseResponse: {
            /** Job Id */
            job_id: string;
            /**
             * Duration
             * @description The duration of the parse request in seconds.
             */
            duration: number;
            /**
             * Pdf Url
             * @description The storage URL of the converted PDF file.
             */
            pdf_url?: string | null;
            usage: components["schemas"]["ParseUsage"];
            /**
             * Result
             * @description The response from the document processing service. Note that there can be two types of responses, Full Result and URL Result. This is due to limitations on the max return size on HTTPS. If the response is too large, it will be returned as a presigned URL in the URL response. You should handle this in your application.
             */
            result: components["schemas"]["FullResult"] | components["schemas"]["UrlResult"];
        };
        /** ParseUsage */
        ParseUsage: {
            /** Num Pages */
            num_pages: number;
        };
        /** ProcessingOptions */
        ProcessingOptions: {
            /**
             * Pdf Ocr
             * @description The method to use for OCR. hybrid uses the PDF text first, then OCR. pdf only uses the PDF text. ocr only uses OCR.
             * @default ocr
             * @enum {string}
             */
            pdf_ocr?: "hybrid" | "pdf" | "ocr";
            /**
             * Ocr System
             * @description The OCR system to use. Defaults to cloud (AWS Textract/Azure DocAI/etc).
             * @default textract
             * @enum {string}
             */
            ocr_system?: "gcloud" | "textract" | "tesseract" | "combined";
            /**
             * Ocr Mode
             * @description The mode to use for OCR. If agentic is enabled, table OCR will be automatically edited.
             * @default standard
             * @enum {string}
             */
            ocr_mode?: "standard" | "agentic";
            /**
             * Document Password
             * @description Password to decrypt password-protected documents.
             */
            document_password?: string;
            /**
             * Table Output Format
             * @description The mode to use for table output. Defaults to html.
             * @default html
             * @enum {string}
             */
            table_output_format?: "html" | "json" | "md" | "dynamic" | "ai_json" | "csv";
            /**
             * Infer Table Color
             * @description If table cell colors should be used to determine table structure. Defaults to False.
             * @default false
             */
            infer_table_color?: boolean;
            /**
             * Chunk Mode
             * @description The mode to use for chunking. Defaults to 'variable'. Section chunks according to sections in the document. Page chunks according to pages. Page sections chunks according to both pages and sections. Disabled returns a single chunk.
             * @default variable
             * @enum {string}
             */
            chunk_mode?: "variable" | "section" | "page" | "disabled" | "block" | "page_sections";
            /**
             * Chunk Size
             * @description The approximate size of chunks (in characters) that the document will be split into. Defaults to None, in which case the chunk size is variable between 250 - 1500 characters.
             */
            chunk_size?: number;
            /**
             * Disable Chunking
             * @description DEPRECATED, use chunk_mode=disabled instead
             * @default false
             */
            disable_chunking?: boolean;
            /**
             * Continue Hierarchy
             * @description A flag to indicate if the hierarchy of the document should be continued from chunk to chunk. E.g. ## Prev Section (cont.)
             * @default true
             */
            continue_hierarchy?: boolean;
            /**
             * Mode
             * @description The type of document to be processed. Defaults to document. If auto is specified, the orientation of the first page will be used to determine the document type.
             * @default document
             * @enum {string}
             */
            mode?: "document" | "deck" | "auto";
            /**
             * Table Summary
             * @description If tables should be summarized for embedding. Defaults to True.
             * @default true
             */
            table_summary?: boolean;
            /**
             * Table Summary Prompt
             * @description Add information to the prompt for table summarization.
             */
            table_summary_prompt?: string;
            /**
             * Figure Summary
             * @description A flag to indicate if figure summarization should be performed. Defaults to False.
             * @default false
             */
            figure_summary?: boolean;
            /**
             * Figure Summary Prompt
             * @description Add information to the prompt for figure summarization.
             */
            figure_summary_prompt?: string;
            /**
             * Figure Summary Override
             * @description If the figure summary prompt should override our default prompt.
             * @default false
             */
            figure_summary_override?: boolean;
            /**
             * Summarize All Figures
             * @description If True, enable figure summaries for all figures regardless of size (onprem only). Defaults to False.
             * @default false
             */
            summarize_all_figures?: boolean;
            /**
             * Chart Extract
             * @description A flag to indicate if bar chart extraction should be performed (requires figure_summary=True). Defaults to False.
             * @default false
             */
            chart_extract?: boolean;
            /**
             * Enrich
             * @description If enabled, a large language/vision model will be used to postprocess the extracted content. Defaults to False.
             * @default false
             */
            enrich?: boolean;
            /**
             * Enrich Prompt
             * @description Add information to the prompt for enrichment.
             */
            enrich_prompt?: string;
            /**
             * Enrich Mode
             * @description The mode to use for enrichment. Defaults to standard
             * @default standard
             * @enum {string}
             */
            enrich_mode?: "standard" | "page" | "table";
            /**
             * Beta Layout Enrichment
             * @description If enabled, a large language/vision model will be used to postprocess the layout predictions. Defaults to False.
             * @default false
             */
            beta_layout_enrichment?: boolean;
            /**
             * Ignore Blocks
             * @description A list of block types to ignore. Defaults to ['Page Number', 'Header', 'Footer', 'Comment'].
             * @default []
             */
            ignore_blocks?: ("Header" | "Footer" | "Title" | "Section Header" | "Page Number" | "List Item" | "Figure" | "Table" | "Key Value" | "Text" | "Comment")[];
            /**
             * Merge Tables
             * @description A flag to indicate if consecutive tables with the same number of columns should be merged. Defaults to False.
             * @default false
             */
            merge_tables?: boolean;
            /**
             * Dpi
             * @description The dots per inch (DPI) setting for image processing. Higher values increase resolution but increase latency. The maximum recommended value is 300.
             * @default 150
             */
            dpi?: number;
            /**
             * Force Url Result
             * @description Force the result to be returned in URL form.
             * @default false
             */
            force_url_result?: boolean;
            /**
             * Force File Extension
             * @description Force the URL to be downloaded as a specific file extension (e.g. `.png`).
             */
            force_file_extension?: string | null;
            /**
             * Custom Format
             * @enum {string}
             */
            custom_format?: "aml" | "ai_usage";
            /**
             * Use Fast Inference
             * @description Use a faster inference model for parsing. Defaults to False.
             * @default false
             */
            use_fast_inference?: boolean;
            /**
             * Use Gpu Ocr
             * @description Use GPU acceleration for OCR processing. Defaults to False.
             * @default false
             */
            use_gpu_ocr?: boolean;
            /**
             * Max Batch Size
             * @description The maximum number of pages to process in a single batch. Defaults to 10.
             * @default 10
             */
            max_batch_size?: number;
            /**
             * Num Ocr Crops
             * @description The dimension of the OCR crops along each axis. num_ocr_crops^2 is the total number of crops. Defaults to 2.
             * @default 2
             */
            num_ocr_crops?: number;
            /**
             * Timeout
             * @description The timeout for the job in seconds. Defaults to 900.
             * @default 900
             */
            timeout?: number;
            /**
             * Extra Metadata
             * @description Extra metadata to be added to logs.
             */
            extra_metadata?: {
                [key: string]: unknown;
            };
            /**
             * Embed Text Metadata Pdf
             * @description If True, embed text metadata into the returned PDF. Defaults to False.
             * @default false
             */
            embed_text_metadata_pdf?: boolean;
            /**
             * Enhanced Docx Conversion
             * @description Instead of using LibreOffice, when enabled, this flag uses a Windows VM to convert docx files. This is slower but more accurate.
             * @default false
             */
            enhanced_docx_conversion?: boolean;
            /**
             * Json Bbox
             * @description If True, include bounding box information in JSON table output. Defaults to False.
             * @default false
             */
            json_bbox?: boolean;
            /**
             * Experimental Large Spreadsheet Table Chunking
             * @description Note, this is an alpha feature subject to change at any time. If enabled, large tables will be chunked into multiple tables. Defaults to False.
             * @default false
             */
            experimental_large_spreadsheet_table_chunking?: boolean;
            /**
             * Use Checkboxes
             * @description Add checkboxes to the output, defaults to False
             * @default false
             */
            use_checkboxes?: boolean;
            /**
             * Use Equations
             * @description Add equations to the output, defaults to False
             * @default false
             */
            use_equations?: boolean;
            /**
             * Page Start
             * @description The page number to start processing from.
             */
            page_start?: number;
            /**
             * Page End
             * @description The page number to stop processing at.
             */
            page_end?: number;
            /**
             * Page Range
             * @description The page range to process.
             * @default {}
             */
            page_range?: components["schemas"]["PageRange"] | components["schemas"]["PageRange"][] | number[];
            /**
             * Keep Line Breaks
             * @description If line breaks should be preserved in the text. Defaults to False.
             * @default false
             */
            keep_line_breaks?: boolean;
            /**
             * Overlap Threshold
             * @description The threshold for box overlap. Defaults to 0.5.
             * @default 0.5
             */
            overlap_threshold?: number;
            /**
             * Large Table Chunking
             * @description If large tables should be chunked into smaller tables, currently only supported on spreadsheet and CSV files.
             * @default true
             */
            large_table_chunking?: boolean;
            /**
             * Large Table Chunking Size
             * @description The max row/column size for a table to be chunked. Defaults to 50.
             * @default 50
             */
            large_table_chunking_size?: number;
            /**
             * Rotate Pages
             * @description Use an orientation model to detect and rotate pages as needed, defaults to False
             * @default false
             */
            rotate_pages?: boolean;
            /**
             * Enable Underlines
             * @description Add <u> tag around text that's underlined and surround strikethroughs and underlines with <change> tags, defaults to False
             * @default false
             */
            enable_underlines?: boolean;
            /**
             * Enable Scripts
             * @description Add <sub> tag around subscripts and <sup> tag around superscripts, defaults to False
             * @default false
             */
            enable_scripts?: boolean;
            /**
             * Enable Comments
             * @description Pull PDF comments from the document, defaults to False
             * @default false
             */
            enable_comments?: boolean;
            /**
             * Return Figure Images
             * @description If figure images should be returned in the result. Defaults to False.
             * @default false
             */
            return_figure_images?: boolean;
            /**
             * Return Table Images
             * @description If table images should be returned in the result. Defaults to False.
             * @default false
             */
            return_table_images?: boolean;
            /**
             * Spreadsheet Table Clustering
             * @description On a spreadsheet, the algorithm that is used to split up sheets into multiple tables.
             * @default default
             * @enum {string}
             */
            spreadsheet_table_clustering?: "default" | "disabled";
            /**
             * Danger Filter Wide Boxes
             * @description If True, filter out boxes with width greater than 50% of the document width. Defaults to False. You probably don't want to use this.
             * @default false
             */
            danger_filter_wide_boxes?: boolean;
            /**
             * Add Page Markers
             * @description If True, add page markers to the output. Defaults to False.
             * @default false
             */
            add_page_markers?: boolean;
            /**
             * Customer Id
             * @description Override the customer ID for the request. Defaults to None.
             */
            customer_id?: string;
            /**
             * Remove Text Formatting
             * @description If True, remove text formatting from the output (e.g. hyphens for list items). Defaults to False.
             * @default false
             */
            remove_text_formatting?: boolean;
            /**
             * Return Ocr Data
             * @description If True, return OCR data in the result. Defaults to False.
             * @default false
             */
            return_ocr_data?: boolean;
            /**
             * Bucket Name
             * @description The name of the bucket to use for the document.
             */
            bucket_name?: string;
            /**
             * Kms Arn
             * @description The AWS KMS key to use for the document.
             */
            kms_arn?: string;
            /**
             * Region Preference
             * @description Forces all external API calls to be routed to specified country/region.
             */
            region_preference?: "us" | null;
            /**
             * Filter Line Numbers
             * @description If True, filter out line numbers from the output. Defaults to False.
             * @default false
             */
            filter_line_numbers?: boolean;
            /**
             * Layout Model
             * @description The layout model to use for the document. This will be deprecated in the future.
             * @default default
             * @enum {string}
             */
            layout_model?: "default" | "beta";
            /**
             * Persist Results
             * @description If True, persist the results indefinitely. Defaults to False.
             * @default false
             */
            persist_results?: boolean;
        };
        /** SplitCategory */
        SplitCategory: {
            /** Name */
            name: string;
            /** Description */
            description: string;
            /** Partition Key */
            partition_key?: string | null;
        };
        /** SplitConfig */
        SplitConfig: {
            /** @default {
             *       "ocr_mode": "standard",
             *       "extraction_mode": "ocr",
             *       "chunking": {
             *         "chunk_mode": "variable"
             *       },
             *       "table_summary": {
             *         "enabled": false
             *       },
             *       "figure_summary": {
             *         "enabled": false,
             *         "override": false
             *       },
             *       "filter_blocks": [],
             *       "force_url_result": false
             *     } */
            options?: components["schemas"]["BaseProcessingOptions"];
            /** @default {
             *       "ocr_system": "highres",
             *       "table_output_format": "html",
             *       "merge_tables": false,
             *       "continue_hierarchy": true,
             *       "keep_line_breaks": false,
             *       "page_range": {},
             *       "large_table_chunking": {
             *         "enabled": true,
             *         "size": 50
             *       },
             *       "spreadsheet_table_clustering": "default",
             *       "add_page_markers": false,
             *       "remove_text_formatting": false,
             *       "return_ocr_data": false,
             *       "filter_line_numbers": false,
             *       "read_comments": false,
             *       "persist_results": false
             *     } */
            advanced_options?: components["schemas"]["AdvancedProcessingOptions"];
            /** @default {
             *       "enrich": {
             *         "enabled": false,
             *         "mode": "standard"
             *       },
             *       "native_office_conversion": false,
             *       "enable_checkboxes": false,
             *       "enable_equations": false,
             *       "rotate_pages": true,
             *       "enable_scripts": false,
             *       "return_figure_images": false,
             *       "return_table_images": false,
             *       "layout_model": "default",
             *       "danger_filter_wide_boxes": false
             *     } */
            experimental_options?: components["schemas"]["ExperimentalProcessingOptions"];
            /**
             * Document Url
             * @description The URL of the document to be processed. You can provide one of the following:
             *     1. A publicly available URL
             *     2. A presigned S3 URL
             *     3. A reducto:// prefixed URL obtained from the /upload endpoint after directly uploading a document
             *     4. A job_id (jobid://) or a list of job_ids (jobid://) obtained from a previous /parse endpoint
             *
             */
            document_url: string | string[] | components["schemas"]["UploadResponse"];
            /**
             * Priority
             * @description If True, attempts to process the job with priority if the user has priority processing budget available; by default, sync jobs are prioritized above async jobs.
             * @default true
             */
            priority?: boolean;
            /**
             * Split Description
             * @description The configuration options for processing the document.
             */
            split_description: components["schemas"]["SplitCategory"][];
            /**
             * Split Rules
             * @description The prompt that describes rules for splitting the document.
             * @default Split the document into the applicable sections. Sections may only overlap at their first and last page if at all.
             */
            split_rules?: string;
        };
        /** SplitResponse */
        SplitResponse: {
            usage: components["schemas"]["ParseUsage"];
            /** @description The extracted response in your provided schema. This is a list of dictionaries. If disbale_chunking is True (default), then it will be a list of length one. */
            result: components["schemas"]["SplitResult"];
        };
        /** SplitResult */
        SplitResult: {
            /** Section Mapping */
            section_mapping: {
                [key: string]: number[];
            };
        };
        /** TableSummaryConfig */
        TableSummaryConfig: {
            /**
             * Enabled
             * @description If table summarization should be performed.
             * @default false
             */
            enabled?: boolean;
            /**
             * Prompt
             * @description Add information to the prompt for table summarization.
             */
            prompt?: string;
        };
        /** UploadResponse */
        UploadResponse: {
            /** File Id */
            file_id: string;
            /** Presigned Url */
            presigned_url?: string | null;
        };
        /** UrlResult */
        UrlResult: {
            /**
             * Type
             * @description type = 'url'
             * @constant
             */
            type: "url";
            /** Url */
            url: string;
            /** Result Id */
            result_id: string;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /** WebhookConfig */
        WebhookConfig: {
            /** Url */
            url?: string | null;
            /**
             * Mode
             * @default direct
             * @enum {string}
             */
            mode?: "direct" | "svix";
            /** Metadata */
            metadata?: unknown;
            /**
             * Channels
             * @description A list of Svix channels the message will be delivered down, omit to send to all channels.
             */
            channels?: string[];
        };
        /** WebhookConfigNew */
        WebhookConfigNew: {
            /**
             * Mode
             * @description The mode to use for webhook delivery. Defaults to 'disabled'. We recommend using 'svix' for production environments.
             * @default disabled
             * @enum {string}
             */
            mode?: "disabled" | "svix" | "direct";
            /**
             * Url
             * @description The URL to send the webhook to (if using direct webhoook).
             */
            url?: string;
            /**
             * Metadata
             * @description JSON metadata included in webhook request body
             */
            metadata?: unknown;
            /**
             * Channels
             * @description A list of Svix channels the message will be delivered down, omit to send to all channels.
             */
            channels?: string[];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    split_split_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SplitConfig"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SplitResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    split_async_split_async_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AsyncSplitConfig"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AsyncSplitResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    parse_parse_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ParseConfigNew"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ParseResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    extract_extract_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ExtractConfigNew"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExtractResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    extract_async_extract_async_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AsyncExtractConfigNew"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AsyncExtractResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    async_parse_parse_async_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AsyncParseConfigNew"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AsyncParseResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    retrieve_parse_job__job_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AsyncJobResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cancel_job_cancel__job_id__post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    upload_upload_post: {
        parameters: {
            query?: {
                extension?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": components["schemas"]["Body_upload_upload_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UploadResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    webhook_portal_configure_webhook_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string;
                };
            };
        };
    };
    get_version_version_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
}
